[General]

# Ini file for an scenario there are two nodes. One node is sending data to other with an interarrival time 7.86432s
# a communicationRange of 25m, variating MO (7,8,9) and SO (3,4,5,6) 
# 

network = inet_dsme.simulations.Net802154


# Logging
cmdenv-event-banners = false
#**.cmdenv-log-level = off # can be info, debug 
#cmdenv-express-mode = true # to generate the minimum version of out file
#lines above are enough to not generate a .out and .elog files

#record an elog? Yes with these two lines the elog and out  files are recorded
**.cmdenv-log-level = debug
cmdenv-express-mode = false
record-eventlog = true
eventlog-file = ${resultdir}/${configname}-${runnumber}.elog 

#
#RANDOM NUMBER GENERATOR
#
# one way to set the seed value recursively by using the value of a repetition as a seed for the next run
seed-set= ${repetition} #the seed of the RNG
repeat = 1 # define the number of different seeds that could be configured
#
seed-set = ${5,6,8..11} # set of seeds manually set up 


# Speed up

**.radioMedium.rangeFilter = "interferenceRange"
**.host[*].wlan[*].radio.*.result-recording-modes = -histogram,-vector
**.host[*].wlan[*].radio.result-recording-modes = -histogram,-vector
**.host[*].wlan[*].radio.transmitter.power = 0.001282mW # -28.9dBm for a transmition range distance equals 25m
#**.host[*].wlan[*].radio.transmitter.power = 0.002904mW # -25.37dBm for a transmition range distance equals 32m
#**.host[*].wlan[*].radio.transmitter.power = 0.005116mW # -22.91dBm for a transmition range distance equals 38m

# Traffic generator
#
#ALTERNATIVE 1: SETTING THE NUMBER OF PACKETS PER INTERVAL THAT A NODE WILL BE SENT
#
**.host[*].trafficgen.packetLength = 75B
#TYPE OF TRAFFIC
#CASE 1: PERIODIC DATA RATE GENERATION
#**.host[*].trafficgen.sendInterval = ${7.86432}s #1 packets
**.host[*].trafficgen.sendInterval = ${1.96608}s # every 1.96608s a packet is generated (4 packets generated per multisuperframe for MO=9 ) 
# **.host[*].trafficgen.sendInterval = fmod(simTime(),2s) < 1s ? 0.4952s:exponential(1s) # every 1s the sendInterval changes from periodic to exponential sending interval
#CASE 2: DATA RATE GENERATION THAT FOLLOWS A EXPONENTIAL DISTRIBUTION (POISSON PROCESS)
**.host[*].trafficgen.startTime = 200s # time at which the traffic generator will be trigered. It is expected that this time is enough to have a complete network set up 
**.host[*].trafficgen.warmUpDuration = 0s #statics start at startTime (warmUp duration= 0)
**.host[*].trafficgen.coolDownDuration = 500s # 500s are waited after the packets has been delivered
**.host[0].trafficgen.continueSendingDummyPackets = false # no dummy packets are sent by node(0)-sink
**.host[*].trafficgen.continueSendingDummyPackets = true # dummy packets are sent in order to have the packets flowing inside the network
**.host[0].trafficgen.numPackets = 0  # no packets are sent by node(0)-sink
**.host[*].trafficgen.numPackets = 20 # nodes in the network send 20 packets
##**.host[1..].trafficgen.numPackets = 100 # other way to define line 49
#
#ALTERNATIVE 2: DEFINING A TOTAL TIME FOR SIMULATION - PACKETS ARE SENT CONTINUOUSLY DURING THIS TIME PERIOD (PACKETS PER INTERVAL)
#
sim-time-limit = 500s
**.host[*].trafficgen.packetLength = 75B
**.host[*].trafficgen.sendInterval = ${1.96608}
#**.host[*].trafficgen.sendInterval = fmod(simTime(), 20s) < 10s ? 1s : 0.05s   #every 10 seconds changes from periodic traffic with a rate of 1 packet per 1s and a rate of 4 packets per 1s
**.host[*].trafficgen.starTime =200s
**.host[*].trafficgen.warmupDuration = 0s
**.host[0].trafficgen.continueSendingDummyPackets = false
**.host[*].trafficgen.continueSendingDummyPackets =  true
**.host[0].trafficgen.numPackets = 0
**.host[*].trafficgen.numPackets = -1 # enable the generation of packets continuously until simulation time has occurred
#
#ALTERNATIVE 3: SENDING A BURST OF PACKETS IN A PERIOD = INTERVAL
#
**.host[*].trafficgen.burstPackets = simTime() < 2000s ? ${BURST= 1,2,3,4,5,6,7,8} : ${0,0,0,0,0,0,0,0} #here there is an additional
**.host[*].trafficgen.sendInterval = ${INTERVAL=7.86432}s 
#condition regarding the simulation time. If the condition is reached then values of BURSTS will change. Burst must be volatile

##
##
**.host[*].wlan[*].mac.queueLength = 100 # to avoid packet loss by queue overflow

#
# DSME 
#
**.host[*].wlan[*].macType = "DSME" # define the type of the MAC
**.host[0].wlan[*].mac.isPANCoordinator = true #define the node that is PAN coordinator
**.host[*].wlan[*].mac.macDSMEGTSExpirationTime = 100 # number of idle Multisuperframes in which a GTS is still valid for two communicating nodes 
**.host[*].wlan[*].mac.macCapReduction = false #capReduction functionality is not enabled(FALSE) 
#**.host[*].wlan[*].mac.superframeOrder = ${SO= 3,4,5,6} #define the superframe order of dsme dataframe structure
#**.host[*].wlan[*].mac.multiSuperframeOrder = ${MO= 7,8,9} #define the multisuperframe order of dsme dataframe structure
**.host[*].wlan[*].mac.beaconOrder = 9# define the beacon order of dsme dataframe structure

#
#SCHEDULER
#CASE 1: TPS FUTURE AND TPS VARIANTS
**.host[*].wlan[*].mac.scheduling = "TPSFUTURE" # define the scheduler 
#**.host[*].wlan[*].mac.scheduling = "TPS"
#**.host[*].wlan[*].mac.TPSalpha = ${0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1}
**.host[*].wlan[*].mac.TPSalpha = 1 # reactivity of the system to deallocations is highest. i.e. the incomming traffic will be allocated in GTS. No filtering 
**.host[*].wlan[*].mac.TPSbeta = 0 # reactivity of the system to deallocations is minimal
**.host[*].wlan[*].mac.useHysteresis = true # enable the hysteresis functionality
**.host[*].wlan[*].mac.useMultiplePacketsPerGTS = false # send only 1 packet per GTS. True means sending the higher number of packets with the max. MPDU 127 bytes (for the scheduler)
**.host[*].**.multiplePacketsPerGTS = false #multiplePacketsPerGTS false for sending 1 packet (in DSME mac-in the Message dispatcher). true enables to send multiple packet

#CASE 2: STATIC SCHEDULING
**.host[*].wlan[*].mac.scheduling = "STATIC"
**.host[*].wlan[*].mac.staticSchedule = xmldoc("static_schedule_four_nodes_one_packet.xml")
**.host[*].wlan[*].mac.channelNegotiation = false # This variable has been implemented to define the channel as a fixed parameter in the xml file
#if channelNegotiation= true means that the simulation will perform the channel negotiation (GTS negotiation), the channel will be ignored.
#find implementation in txrxvariant of opendsme_workspace or in google drive
#example of an xml file
#
#<?xml version="1.0" encoding="UTF-8"?>
#<root>
#    <node id="1">
#        <slot slotID="5" superframeID="1" channelID="2" direction="1" address="2"></slot>
#    </node>
#    <node id="2">
#        <slot slotID="5" superframeID="1" channelID="2" direction="0" address="1"></slot>
#    </node>
#</root>

#
#routing 
#
#ALTERNATIVE 1: STATIC ROUTING by using a GENERICNETWORKCONFIGURATOR
#Adds routes to a GenericRoutingTable similarly how Ipv4NetworkConfigurator adds
#static routes to Ipv4RoutingTable.	(Uses shortest path decision based on cost of
#nodes that are function of the index of a node. PLEASE review this!)			
#
**.host[*].hasGpsr = false # disable the GPSR routing algorithm 
**.routingTableModule = "^.routingTable"
**.routingTable.addressType = "modulepath" #modulepath defines the address of the receiving node
**.configurator.addStaticRoutes = true #define static routes as routing
**.configurator.dumpTopology = true #'print extracted network topology to the module output'
**.configurator.dumpRoutes = true #'print configured and optimized routing tables for all nodes to the module output'
**.configurator.config = xmldoc("./ini_xml_files/line2n_scenario1/topology_l2n_scenario1.xml") #file generated with
#pyton library "topology" created by Florian Meyer
# COMUNICATION PARTNERS

#CASE 1: CONVERGECAST -> ALL Nodes send data to the same node
**.host[*].trafficgen.destAddresses = "host[0](modulepath)" # define host[0] as destination Address

#CASE 2: COMMUNICATION WITH DIFFERENT PARTNERS (PREDEFINED communication partners)
#include /home/ivanmago/workspace_burstNormal/inet-dsme/simulations/ini_xml_files/grid_3n/communication_g3.ini
#file generated with python library "topology" created by Florian Meyer.


#
#ALTERNATIVE 2: USING THE GPSR routing protocol
#
#**.host[*].hasGpsr = true # this line is not required given that the routing algorithm by default is GPSR

# Mobility
**.host[*].mobilityType = "StaticPresetMobility" #define the topology (position of nodes manually)
**.numHosts = 2
#
#ALTERNATIVE 1: setting the positions inside the ini file
#
**.host[0].**.posX = 0 m
**.host[0].**.posY = 0 m
**.host[0].**.posZ = 0.0 m
**.host[1].**.posX = 0 m
**.host[1].**.posY = 14 m
**.host[1].**.posZ = 0.0 m
#
#ALTERNATIVE 2: setting the positions in another ini file
#
#include /home/ivanmago/workspace_burstNormal/inet-dsme/simulations/positions_g7n_CFP.ini #Positions are stored in positions_g7n_CFP.ini
#file generated with python library "topology" created by Florian Meyer.

#
#ALTERNATIVE 3: USING THE LIBRARIES FROM OMNETPP
# FOR LINE TOPOLOGY
#**.host[*].mobilityType = "StaticLinearMobility"
#**.host[*].mobility.initialX = 100m
#**.host[*].mobility.initialY = 200m
#**.host[*].mobility.orientation = 0
#**.host[*].mobility.separation = 130m 

#FOR BINARY TREE (PLEASE REVIEW DEFINITION OF PARAMETERS)
#**.host[*].mobilityType = "StaticBinaryTreeMobility"
#**.host[*].mobility.initialX = 100m
#**.host[*].mobility.initialY = 200m
#**.host[*].mobility.initialZ = 0m
#**.host[0].mobility.distance = 0m
#**.host[*].mobility.distance = 130m

#Restrictions over the canvas area
#
**.constraintAreaMaxX = 50000 m
**.constraintAreaMaxY = 50000 m
**.constraintAreaMinX = -50000 m
**.constraintAreaMinY = -50000 m


**.host[*].wlan[*].mac.superframeOrder = ${SO= 3} #define the superframe order of dsme dataframe structure
**.host[*].wlan[*].mac.multiSuperframeOrder = ${MO= 9} #define the multisuperframe order of dsme dataframe structure



